# X-Slot 无线互联协议文档

## 目录
1. [架构设计](#架构设计)
2. [协议规范](#协议规范)
3. [API参考](#api参考)
4. [快速开始](#快速开始)
5. [移植指南](#移植指南)

---
## 需求
### 1. 数据连接场景

DDC是类似PLC的楼宇控制器，DDC电路板上预留了UART/SPI的接口，以这两个通信口为基础，搭配上不同的扩展模块，来实现不同的功能。而X-SLOT就是基于该扩展设计出来的协议。
主要涉及设备发现、数据传输、设备管理等，将x-slot形成SDK，集成到DDC或者其他模块中，根据协议能够读取和控制数据。
DDC是一个bancet server(IP), 对DDC的控制主要以bacnet协议访问为主。

- DDC无线互联场景(核心场景)
DDC插上无线模块TP1107，无线模块通过串口与DDC主板相连。TP1107的指令和功能参考 TPMESH.md, 这种场景下，DDC之间可以通过无线模块的mesh组网进行互联。最终由一台汇聚DDC从网口端将所有的数据传输出去。因此，该协议sdk会嵌入到DDC中，BACNET server将object和property通过协议传输出去，汇聚节点的DDC接收到数据，重新映射到新的device id上。

- DDC与IO模块无线互联场景
IO模块与DDC之间相互连接，一个DDC可以连接多个IO模块，IO模块与DDC都插上无线模块。技术和流程上与 DDC无线互联场景一致。

- DDC与HMI直连场景
HMI屏幕差到DDC上，可以用来显示DDC上的一些数据。这种情况下，需要DDC和HMI屏上都跑协议。HMI会拿到相关数据，根据自己配置来选择显示哪些数据。

- 未来扩展(TODO)

### 2.配置场景
- DDC通过上层PC软件进行编程和配置，比如三方通信口等，这也是DDC配置系统的入口，因此协议栈SDK需要支持配置的接口，能够通过DDC扩展协议去支持二次配置。
- 配置工具通过网线或者串口跟DDC连接，进行配置下载、上传、仿真等，走的协议是modbus或者bacnet。通常是DDC解析配置，再对子模块进行操作
- 对于无线通信，会配置这台设备的角色(汇聚节点还是普通节点)
- 对于HMI，则是配置HMI模式，这样数据就不用再走AT模式,而是串口直连


## 架构设计

### 1. 系统概述

X-Slot是为DDC控制器设计的无线互联协议，支持TP1107 470MHz Mesh模块和HMI串口直连两种模式。

### 2. 分层架构

```
┌─────────────────────────────────┐
│   应用层 Application Layer      │
│   - BACnet Server               │
│   - 设备对象管理                │
│   - COV通知                     │
├─────────────────────────────────┤
│   X-Slot协议层 Protocol Layer   │
│   - XSlotManager                │
│   - MessageCodec                │
│   - NodeTable                   │
│   - CommandHandler              │
├─────────────────────────────────┤
│   传输抽象层 Transport Layer    │
│   - ITransport (接口)           │
│   - ATTransport (TP1107)        │
│   - DirectTransport (HMI)       │
├─────────────────────────────────┤
│   硬件抽象层 HAL Layer          │
│   - SerialPort                  │
│   - Thread/Mutex                │
│   - Time functions              │
└─────────────────────────────────┘
```

### 3. 核心组件

#### 3.1 XSlotManager
协议栈核心管理器，负责：
- 节点管理和心跳监控
- 数据收发调度
- 路由维护
- 回调分发

#### 3.2 MessageCodec
消息编解码器，实现：
- 帧格式编码/解码
- CRC16校验
- 调试输出

#### 3.3 TPMesh传输层（两层架构）

为实现清晰的职责分离，TPMesh通信模块采用**两层架构**设计：

##### 3.3.1 TPMeshATDriver（AT驱动层）
纯粹的AT命令抽象层，与业务逻辑完全解耦：
- **职责**：
  - 串口收发管理
  - AT命令同步发送（阻塞等待OK/ERROR）
  - 区分同步响应和URC事件
  - 通过回调通知URC事件
- **不关心**：
  - 帧追踪和发送状态
  - 业务队列管理
  - X-Slot协议细节
- **关键特性**：
  - 状态机区分IDLE和WAITING_RESPONSE
  - URC识别：+NNMI, +SEND, +ROUTE, +ACK等
  - 线程安全的URC回调机制

##### 3.3.2 TPMeshTransport（传输层）
处理URC事件和业务逻辑：
- **职责**：
  - 使用ATDriver发送数据
  - 接收并解析URC事件
  - 维护X-Slot帧接收队列
  - （可选）追踪发送状态（+SEND事件）
  - 路由变化通知（+ROUTE事件）
- **URC事件处理**：
  - +NNMI → 解析X-Slot帧 → 推入接收队列
  - +SEND → 更新发送状态追踪表
  - +ROUTE → 通知路由变化回调
   - +ACK → 送达确认通知

- **发送策略**：
  - 默认使用 `Type 0 (UM)` 模式发送。
  - 理由：避免链路层ACK与应用层ACK双重确认导致的高延迟，由应用层SEQ保障可靠性。

#### 3.4 DirectTransport（HMI直连层）

针对HMI场景，采用直连传输层：
- **职责**：
  - 纯串口透传，不使用AT指令封装
  - 自动识别并剥离/添加 `SYNC` 帧头
  - 处理 HMI 侧的查询指令 (`QUERY`)
- **模式切换**：
  - 系统启动时通过 `xslot_detect_mode()` 检测硬件连接状态
  - 支持动态切换 Transport 实现

#### 3.5 BACnet序列化器（支持增量传输）

BACnet对象序列化器，支持两种格式以优化无线传输：

##### 3.4.1 完整格式（BACnetSerializer）
用于初次上报、属性读写：
- 包含完整的对象元数据
- 格式：[OBJ_ID:2] [OBJ_TYPE:1] [FLAGS:1] [VALUE:变长]
- FLAGS bit7=0 表示完整格式

##### 3.4.2 增量格式（BACnetIncrementalSerializer）
用于COV上报，仅传输Present_Value：
- 省略OBJ_TYPE和FLAGS，节省2字节
- 格式：[OBJ_ID:2] [TYPE_HINT:1] [VALUE:变长]
- TYPE_HINT bit7=1 表示增量格式
- TYPE_HINT bit3-0 指示值类型（0=ANALOG, 1=BINARY, 2=OTHER）

**效率对比**：
- 完整格式：1个AI对象 = 8字节
- 增量格式：1个AI对象 = 6字节（节省25%）
- 10个AI批量：完整80字节，增量61字节（节省24%）

**使用策略**：
- 首次上报：完整格式（建立对象定义）
- COV上报：增量格式（只传Present_Value）
- 属性读写：完整格式（携带元数据）
- 定期全量：每10次增量后发送一次完整格式（防止漂移）

---

## 协议规范

### 1. 消息帧格式

```
┌──────┬────────┬────────┬──────┬──────┬──────┬────────────┬────────┐
│ SYNC │  FROM  │   TO   │ SEQ  │ CMD  │ LEN  │    DATA    │  CRC16 │
│ 1B   │  2B    │  2B    │  1B  │  1B  │  1B  │  0-128B    │  2B    │
└──────┴────────┴────────┴──────┴──────┴──────┴────────────┴────────┘
```

#### 字段说明
- **SYNC**: 同步字节，固定为`0xAA`
- **FROM**: 源地址，小端序，2字节
- **TO**: 目标地址，小端序，2字节
- **SEQ**: 序列号，0-255循环，用于去重和确认
- **CMD**: 命令类型，见下表
- **LEN**: 数据长度，0-128字节
- **DATA**: 载荷数据
- **CRC16**: CCITT标准CRC校验

### 2. 命令类型

| 命令码 | 名称 | 方向 | 说明 |
|--------|------|------|------|
| 0x01 | PING | 双向 | 心跳请求 |
| 0x02 | PONG | 双向 | 心跳响应 |
| 0x10 | REPORT | 边缘→汇聚 | 数据上报 |
| 0x11 | QUERY | HMI→汇聚 | 数据查询 |
| 0x12 | RESPONSE | 汇聚→HMI | 查询响应 |
| 0x20 | WRITE | 汇聚→边缘 | 远程写入 |
| 0x21 | WRITE_ACK | 边缘→汇聚 | 写入确认 |

### 3. 地址定义

| 地址范围 | 类型 | 说明 |
|----------|------|------|
| 0xFFFE | 汇聚节点 | 网关固定地址 |
| 0xFFBE-0xFFFD | 边缘节点 | 最多64个边缘节点 |
| 0xFF00 | HMI | HMI固定地址 |


### 4. BACnet对象序列化格式和协议
本协议采用**双轨制**序列化方案，以平衡高频的COV上报和低频的属性读写。

#### 格式 A: COV上报格式 (用于 `CMD_REPORT = 0x10`)

此格式专用于边缘节点批量上报 `Present_Value`，追求极致的效率。

**单个对象 (仅 `Present_Value`)**

[CMD(REPORT) 1B][LEN 1B][COUNT]

**多个对象 (批量上报)**
│ COUNT │ OBJ1 │ OBJ2 │ ... │ │ 1B │ (格式见上) │ (格式见上) │ │

#### 格式 B: 属性读写格式 (用于 `CMD_QUERY/RESPONSE/WRITE/WRITE_ACK`)


**`CMD_WRITE (0x20)` / `CMD_RESPONSE (0x12)` 载荷**
*(写入属性 或 读取属性的响应)*

#### 单个对象
```
┌─────────┬─────────┬────────┬──────────────┐
│ OBJ_ID  │ OBJ_TYPE│ FLAGS  │    VALUE     │
│  2B     │   1B    │   1B   │   变长       │
└─────────┴─────────┴────────┴──────────────┘
```

#### 多个对象
```
┌───────┬────────┬────────┬────────┐
│ COUNT │ OBJ1   │ OBJ2   │ ...    │
│  1B   │        │        │        │
└───────┴────────┴────────┴────────┘
```

#### 值类型编码
- **模拟值（AI/AO/AV）**: 4字节IEEE 754浮点数
- **二进制值（BI/BO/BV）**: 1字节，0或1
- **其他类型**: 16字节原始数据

### 5. 通信流程

#### 5.1 启动与心跳建立
```
边缘节点         汇聚节点
   │                │
   ├─── PING ───────>│
   │<─── PONG ───────┤
   │                │
  (建议30s-60s重复，或无数据时发送)
```

#### 5.2 数据上报
```
边缘节点         汇聚节点
   │                │
   ├─ REPORT(data) ─>│
   │                │ (缓存到节点表)
```

#### 5.3 远程写入
```
汇聚节点         边缘节点
   │                │
   ├─ WRITE(obj) ───>│
   │                │ (更新本地对象)
   │<─ WRITE_ACK ────┤
```

---

## API参考

### 1. C API

#### 初始化与清理

```c
// 初始化协议栈
xslot_handle_t xslot_init(const xslot_config_t* config);

// 释放资源
void xslot_deinit(xslot_handle_t handle);

// 启动协议栈
int xslot_start(xslot_handle_t handle);

// 停止协议栈
void xslot_stop(xslot_handle_t handle);
```

#### 数据操作

```c
// 上报BACnet对象
int xslot_report_objects(xslot_handle_t handle, 
                         const xslot_bacnet_object_t* objects,
                         uint8_t count);

// 远程写入对象
int xslot_write_object(xslot_handle_t handle,
                       uint16_t target,
                       const xslot_bacnet_object_t* obj);

// 查询节点对象
int xslot_query_objects(xslot_handle_t handle,
                        uint16_t target,
                        const uint16_t* object_ids,
                        uint8_t count);
```

#### 节点管理

```c
// 发送心跳
int xslot_send_ping(xslot_handle_t handle, uint16_t target);

// 获取节点列表
int xslot_get_nodes(xslot_handle_t handle,
                    xslot_node_info_t* nodes,
                    int max_count);
```

#### 回调设置

```c
// 数据接收回调
typedef void (*xslot_data_received_cb)(uint16_t from, 
                                       const uint8_t* data, 
                                       uint8_t len);
void xslot_set_data_callback(xslot_handle_t handle, 
                              xslot_data_received_cb callback);

// 节点上下线回调
typedef void (*xslot_node_online_cb)(uint16_t addr, bool online);
void xslot_set_node_callback(xslot_handle_t handle, 
                              xslot_node_online_cb callback);

// 写入请求回调
typedef void (*xslot_write_request_cb)(uint16_t from, 
                                       const xslot_bacnet_object_t* obj);
void xslot_set_write_callback(xslot_handle_t handle, 
                               xslot_write_request_cb callback);
```

#### TP1107配置

```c
// 配置TP1107模块参数
int xslot_configure_tp1107(xslot_handle_t handle,
                           uint16_t addr,
                           uint8_t cell_id,
                           int8_t power_dbm);
```

### 2. AT命令参考

#### 基础命令
```
AT              // 测试连接
AT+VER?         // 查询版本
AT+ESN?         // 查询ESN
AT+REBOOT       // 软重启
```

#### 配置命令
```
AT+ADDR=<addr>[,<group_addr>]   // 配置地址
AT+CELL=<cell_id>               // 配置小区ID
AT+PWR=<dbm>                    // 配置发射功率(-30~20dBm)
AT+WOR=<period>                 // 配置唤醒周期(ms)
AT+BPS=<type>,<bps>             // 配置通信速率
AT+LP=<mode>                    // 配置功耗模式(2=TypeC, 3=TypeD)
```

#### 查询命令
```
AT+ADDR?        // 查询地址
AT+CELL?        // 查询小区ID
AT+PWR?         // 查询发射功率
AT+WOR?         // 查询唤醒周期
AT+BPS?         // 查询通信速率
AT+LP?          // 查询功耗模式
```

#### 数据发送
```
AT+SEND=<ADDR>,<LEN>,<DATA>,<TYPE>

参数:
  ADDR - 目标地址(Hex, 2字节)
  LEN  - 数据长度(Dec)
  DATA - 数据内容(Hex字符串)
  TYPE - 消息类型(0=UM, 1=AM, 2=FAST, 3=FLOOD)

示例:
AT+SEND=FFFE,5,0123456789,0
```

#### URC指示

**数据接收**
```
+NNMI:<SRC>,<DEST>,<RSSI>,<LEN>,<DATA>

示例:
+NNMI:FFFE,0001,-80,10,00112233445566778899
```

**发送状态**
```
+SEND:<SN>,<RESULT>

结果码:
  HANDLE OK    - 已加入发送队列
  PREPARE      - 开始发送
  SEND OK      - 发送成功
  SEND ERROR   - 发送失败
  JOINING      - 正在建立路由
```

**路由管理**
```
+ROUTE:CREATE ADDR[<addr>]  // 路由创建
+ROUTE:DELETE ADDR[<addr>]  // 路由删除
```

---

## 快速开始

### 1. Windows平台编译

#### 环境要求
- CMake 3.15+
- Visual Studio 2017+ 或 MinGW-w64
- C++14编译器

#### 编译步骤

```bash
# 克隆代码
git clone <repository_url>
cd xslot

# 创建构建目录
mkdir build
cd build

# 生成项目
cmake ..

# 编译
cmake --build . --config Release

# 运行Demo
./bin/demo/demo_basic.exe
./bin/demo/demo_gateway.exe
./bin/demo/demo_edge_node.exe 0xFFBE
```

### 2. 示例代码

#### 网关节点
```c
#include "xslot.h"

void on_data_received(uint16_t from, const uint8_t* data, uint8_t len) {
    printf("Received %d bytes from 0x%04X\n", len, from);
}

int main() {
    // 配置
    xslot_config_t config = {0};
    config.local_addr = XSLOT_ADDR_HUB;
    config.cell_id = 1;
    config.power_dbm = 20;
    config.uart_baudrate = 115200;
    config.heartbeat_interval_ms = 5000;
    
    // 初始化
    xslot_handle_t handle = xslot_init(&config);
    xslot_set_data_callback(handle, on_data_received);
    
    // 配置TP1107
    xslot_configure_tp1107(handle, config.local_addr, 
                          config.cell_id, config.power_dbm);
    
    // 启动
    xslot_start(handle);
    
    // 主循环
    while (running) {
        sleep(1);
    }
    
    // 清理
    xslot_stop(handle);
    xslot_deinit(handle);
    return 0;
}
```

#### 边缘节点
```c
#include "xslot.h"

int main() {
    // 配置
    xslot_config_t config = {0};
    config.local_addr = 0xFFBE;  // 边缘节点地址
    config.cell_id = 1;
    config.power_dbm = 20;
    config.uart_baudrate = 115200;
    config.heartbeat_interval_ms = 5000;
    
    // 初始化并启动
    xslot_handle_t handle = xslot_init(&config);
    xslot_configure_tp1107(handle, config.local_addr, 
                          config.cell_id, config.power_dbm);
    xslot_start(handle);
    
    // 定期上报数据
    while (running) {
        // 准备BACnet对象
        xslot_bacnet_object_t obj = {0};
        obj.object_id = 0;
        obj.object_type = BACNET_OBJ_ANALOG_INPUT;
        obj.value.analog_value = read_temperature();
        
        // 上报
        xslot_report_objects(handle, &obj, 1);
        
        sleep(5);
    }
    
    // 清理
    xslot_stop(handle);
    xslot_deinit(handle);
    return 0;
}
```

---

## 移植指南

### 1. 移植到FreeRTOS/GD32

#### 1.1 HAL层适配

需要实现以下接口：

```cpp
// src/hal/xslot_hal_freertos.cpp

namespace xslot {
namespace hal {

// 时间函数
uint32_t getTimestamp() {
    return xTaskGetTickCount() * portTICK_PERIOD_MS;
}

void sleep(uint32_t ms) {
    vTaskDelay(pdMS_TO_TICKS(ms));
}

// 线程实现
class Thread::Impl {
    TaskHandle_t task_handle_;
    // ...实现...
};

// 互斥锁实现
class Mutex::Impl {
    SemaphoreHandle_t mutex_;
    // ...实现...
};

// 串口实现
class SerialPort::Impl {
    USART_TypeDef* usart_;
    // 使用GD32 HAL库实现...
};

} // namespace hal
} // namespace xslot
```

#### 1.2 CMake配置

```cmake
# 设置FreeRTOS平台
set(XSLOT_PLATFORM_FREERTOS ON)

# 添加GD32 SDK路径
include_directories(
    ${GD32_SDK_PATH}/CMSIS
    ${GD32_SDK_PATH}/GD32F4xx_standard_peripheral
    ${FREERTOS_PATH}/include
)

# 链接FreeRTOS库
target_link_libraries(xslot freertos gd32_hal)
```

#### 1.3 内存优化

对于嵌入式平台，建议：
- 减小`XSLOT_MAX_DATA_LEN`到64字节
- 限制`XSLOT_MAX_NODES`到16个
- 使用静态内存分配
- 调整栈大小（建议4KB）

### 2. 集成到BACnet应用

```c
// 在BACnet应用中集成X-Slot

#include "xslot.h"
#include "bacnet/bacnet.h"

// 上报回调
void on_xslot_data(uint16_t from, const uint8_t* data, uint8_t len) {
    // 反序列化BACnet对象
    xslot_bacnet_object_t objects[16];
    int count = deserialize_objects(data, len, objects, 16);
    
    // 更新本地设备树
    for (int i = 0; i < count; i++) {
        bacnet_update_object(from, &objects[i]);
    }
}

// Who-Is处理
void handle_bacnet_whois() {
    // 查询所有在线节点
    xslot_node_info_t nodes[64];
    int count = xslot_get_nodes(handle, nodes, 64);
    
    // 回复I-Am（包含汇聚节点和所有边缘节点）
    for (int i = 0; i < count; i++) {
        if (nodes[i].online) {
            bacnet_send_iam(nodes[i].addr);
        }
    }
}
```

### 3. 性能优化建议

1. **批量上报**：将多个对象打包成一个REPORT消息
2. **COV模式**：只在值变化时上报，减少无效通信
3. **心跳间隔**：建议调大至30-60秒，避免信道拥塞
4. **功率配置**：根据距离调整发射功率，节省能耗
5. **空口速率**：优先使用76.8Kbps以减少延时

---

## 故障排查

### 常见问题

**Q: 模块无响应**
- 检查串口波特率（默认115200）
- 确认串口硬件连接
- 尝试发送AT命令测试

**Q: 路由建立失败**
- 检查地址配置（0xFFBE-0xFFFE）
- 确认小区ID一致
- 检查发射功率设置

**Q: 数据丢失**
- 增大心跳超时时间
- 检查信号强度（RSSI）
- 降低数据发送频率

**Q: 编译错误**
- 确认CMake版本≥3.15
- 检查C++标准设置（需C++14）
- Windows下使用MinGW或MSVC

---

## 附录

### A. 错误码表

| 错误码 | 宏定义 | 说明 |
|--------|--------|------|
| 0 | XSLOT_OK | 成功 |
| -1 | XSLOT_ERR_PARAM | 参数错误 |
| -2 | XSLOT_ERR_TIMEOUT | 超时 |
| -3 | XSLOT_ERR_CRC | CRC校验失败 |
| -4 | XSLOT_ERR_NO_MEM | 内存不足 |
| -5 | XSLOT_ERR_BUSY | 系统繁忙 |
| -6 | XSLOT_ERR_OFFLINE | 节点离线 |

### B. 版本历史

- **v1.0.0** (2025-01-15)
  - 初始版本
  - 支持TP1107模块
  - 实现基础协议栈
  - BACnet对象序列化

